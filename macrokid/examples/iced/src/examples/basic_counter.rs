use iced::{Element, Result};
use iced::widget::{button, text, column};
use iced_macrokid::{IcedApp, iced_view};

/// A simple counter application demonstrating macrokid + iced integration
/// 
/// This example shows how macrokid can eliminate the typical Iced boilerplate:
/// - No manual Message enum definition
/// - No manual update function implementation
/// - Simplified view syntax with helper macros
/// 
/// Compare this to a traditional Iced counter which requires ~50+ lines
#[derive(IcedApp, Default)]
#[title("Macrokid Counter")]
struct CounterApp {
    value: i32,
}

impl CounterApp {
    // Methods marked with #[message] automatically generate Message enum variants
    // and are called by the generated update function
    
    #[message]
    fn increment(&mut self) {
        self.value += 1;
        println!("Incremented to: {}", self.value);
    }
    
    #[message] 
    fn decrement(&mut self) {
        self.value -= 1;
        println!("Decremented to: {}", self.value);
    }
    
    #[message]
    fn reset(&mut self) {
        self.value = 0;
        println!("Reset to: {}", self.value);
    }
}

// The #[iced_view] attribute provides helper macros for common widgets
#[iced_view]
impl CounterApp {
    fn view(&self) -> Element<Message> {
        column![
            // Helper macros make widget creation more concise
            text!("Counter Example").size(24),
            text!(format!("Value: {}", self.value)).size(18),
            
            // Traditional Iced syntax still works
            button(text("+")).on_press(Message::Increment),
            button(text("-")).on_press(Message::Decrement), 
            button(text("Reset")).on_press(Message::Reset),
        ]
        .spacing(10)
        .padding(20)
        .into()
    }
}

fn main() -> Result {
    println!("Starting Macrokid Counter Example...");
    
    // The IcedApp derive automatically implements iced::Application
    // So we can run it directly without additional boilerplate
    iced::run(
        "Macrokid Counter",
        CounterApp::update,
        CounterApp::view
    )
}

// Alternative main using the Application trait (generated by IcedApp derive)
#[allow(dead_code)]
fn main_alternative() -> Result {
    CounterApp::run(iced::Settings::default())
}