use crate::ir::*;

// Type-state markers
pub struct Empty;
pub struct HasApp;
pub struct HasWindow;
pub struct HasGraph;
pub struct Complete;

#[derive(Default)]
pub struct EngineBuilder<State> {
    state: core::marker::PhantomData<State>,
    app: Option<&'static str>,
    window: Option<WindowCfg>,
    pipelines: Vec<PipelineDesc>,
}

impl EngineBuilder<Empty> {
    pub fn new() -> Self { Self { state: core::marker::PhantomData, app: None, window: None, pipelines: vec![] } }
    pub fn app(mut self, name: &'static str) -> EngineBuilder<HasApp> {
        self.app = Some(name);
        EngineBuilder { state: core::marker::PhantomData, app: self.app, window: self.window, pipelines: self.pipelines }
    }
}

impl EngineBuilder<HasApp> {
    pub fn window(mut self, width: u32, height: u32, vsync: bool) -> EngineBuilder<HasWindow> {
        self.window = Some(WindowCfg { width, height, vsync });
        EngineBuilder { state: core::marker::PhantomData, app: self.app, window: self.window, pipelines: self.pipelines }
    }
}

#[derive(gfx_dsl_builder_derive::FluentBuilder)]
#[builder_transition(
    method = "finish",
    to = "EngineBuilder<HasGraph>",
    receiver = "self",
    body = "{ let engine = self.engine; EngineBuilder { state: core::marker::PhantomData, app: engine.app, window: engine.window, pipelines: engine.pipelines } }"
)]
pub struct GraphBuilder { engine: EngineBuilder<HasWindow> }

impl EngineBuilder<HasWindow> {
    pub fn graph(self) -> GraphBuilder { GraphBuilder { engine: self } }
}

#[derive(gfx_dsl_builder_derive::FluentBuilder)]
#[builder_transition(
    method = "finish_pass",
    to = "GraphBuilder",
    receiver = "self",
    body = "{ self.graph }"
)]
pub struct PassBuilder {
    graph: GraphBuilder,
    pass: &'static str,
}

impl GraphBuilder {
    pub fn add_pass(self, name: &'static str) -> PassBuilder { PassBuilder { graph: self, pass: name } }
}

#[derive(gfx_dsl_builder_derive::FluentBuilder)]
#[builder_transition(
    method = "finish",
    to = "PassBuilder",
    receiver = "self",
    body = "{ let desc = PipelineDesc { pass: self.parent.pass, name: self.name, shaders: self.shaders, topology: self.topology, depth: self.depth }; let mut parent = self.parent; parent.graph.engine.pipelines.push(desc); PassBuilder { graph: parent.graph, pass: parent.pass } }"
)]
pub struct PipelineBuilder {
    parent: PassBuilder,
    name: &'static str,
    #[builder(tuple = "(vs: &'static str, fs: &'static str) => ShaderPaths { vs, fs }", name = "shaders")]
    shaders: ShaderPaths,
    #[builder]
    topology: Topology,
    #[builder]
    depth: bool,
}

impl PassBuilder {
    pub fn add_pipeline(self, name: &'static str) -> PipelineBuilder {
        PipelineBuilder { parent: self, name, shaders: ShaderPaths { vs: "", fs: "" }, topology: Topology::TriangleList, depth: true }
    }
}

#[allow(dead_code)]
impl PipelineBuilder {}

// finish() now generated by #[builder_transition]

impl EngineBuilder<HasGraph> {
    pub fn build(self) -> Result<EngineConfig, ValidationError> {
        let app = self.app.unwrap_or("Untitled");
        let window = self.window.unwrap_or(WindowCfg { width: 1280, height: 720, vsync: true });
        let pipelines_vec = self.pipelines;
        let cfg = EngineConfig {
            app,
            window,
            pipelines: Box::leak(pipelines_vec.into_boxed_slice()),
        };
        validate_config(&cfg)?;
        Ok(cfg)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ValidationError {
    NoPipelines,
    EmptyShaderPath { pass: &'static str, pipeline: &'static str, which: &'static str },
    DuplicatePipeline { pass: &'static str, pipeline: &'static str },
}

pub fn validate_config(cfg: &EngineConfig) -> Result<(), ValidationError> {
    use std::collections::HashSet;
    if cfg.pipelines.is_empty() { return Err(ValidationError::NoPipelines); }
    let mut seen: HashSet<(&'static str, &'static str)> = HashSet::new();
    for p in cfg.pipelines.iter() {
        if p.shaders.vs.is_empty() { return Err(ValidationError::EmptyShaderPath { pass: p.pass, pipeline: p.name, which: "vs" }); }
        if p.shaders.fs.is_empty() { return Err(ValidationError::EmptyShaderPath { pass: p.pass, pipeline: p.name, which: "fs" }); }
        let key = (p.pass, p.name);
        if !seen.insert(key) { return Err(ValidationError::DuplicatePipeline { pass: p.pass, pipeline: p.name }); }
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn builder_happy_path() {
        let cfg = EngineBuilder::<Empty>::new()
            .app("Demo")
            .window(800, 600, true)
            .graph()
                .add_pass("main")
                    .add_pipeline("triangle")
                        .shaders("vs", "fs")
                        .finish()
                .finish_pass()
            .finish()
            .build()
            .expect("valid");
        assert_eq!(cfg.window.width, 800);
        assert_eq!(cfg.pipelines.len(), 1);
    }

    #[test]
    fn builder_missing_shaders_is_error() {
        let res = EngineBuilder::<Empty>::new()
            .app("Demo")
            .window(800, 600, true)
            .graph()
                .add_pass("main")
                    .add_pipeline("triangle")
                        .finish()
                .finish_pass()
            .finish()
            .build();
        assert!(matches!(res, Err(ValidationError::EmptyShaderPath { which: "vs", .. }))); // vs defaults to empty first
    }
}
